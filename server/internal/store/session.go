package store

import (
	"encoding/json"
	"fmt"
	"math/rand"
	"os"
	"path/filepath"
	"sort"
	"sync"
	"time"
)

const activeSessionFile = "active.txt"

type SessionStore struct {
	mu     sync.RWMutex
	dir    string
	active string
}

func NewSessionStore(dir string) (*SessionStore, error) {
	if err := os.MkdirAll(dir, 0755); err != nil {
		return nil, err
	}
	s := &SessionStore{dir: dir}
	s.active, _ = s.readActive()
	return s, nil
}

type AgentSessionState struct {
	SessionID      string                 `json:"sessionId"`
	Title          string                 `json:"title,omitempty"`
	GeminiHistory  []any                  `json:"geminiHistory"`
	UIMessages     []any                  `json:"uiMessages"`
	VFS            map[string]VfsFile     `json:"vfs"`
	KnowledgeChunks []KnowledgeChunk       `json:"knowledgeChunks,omitempty"`
	LastUpdated    int64                  `json:"lastUpdated"`
}

type VfsFile struct {
	Path     string `json:"path"`
	Content  string `json:"content"`
	Language string `json:"language"`
	IsWriting bool  `json:"isWriting,omitempty"`
}

type KnowledgeChunk struct {
	Content        string `json:"content"`
	Summary        string `json:"summary"`
	BoundaryReason string `json:"boundaryReason"`
}

type SessionMeta struct {
	SessionID   string `json:"sessionId"`
	Title       string `json:"title"`
	LastUpdated int64  `json:"lastUpdated"`
}

func DefaultVFS() map[string]VfsFile {
	return map[string]VfsFile{
		"README.md": {
			Path:     "README.md",
			Content:  "# Enterprise Agentic Project\n\nGenerated by Gemini 3 Supervisor.",
			Language: "markdown",
		},
	}
}

func (s *SessionStore) CreateSession() (string, error) {
	s.mu.Lock()
	defer s.mu.Unlock()
	id := genSessionID()
	state := AgentSessionState{
		SessionID:      id,
		Title:          "新会话",
		GeminiHistory:  []any{},
		UIMessages:     []any{},
		VFS:            DefaultVFS(),
		KnowledgeChunks: []KnowledgeChunk{},
		LastUpdated:    nowMs(),
	}
	if err := s.writeSession(id, state); err != nil {
		return "", err
	}
	s.active = id
	_ = os.WriteFile(filepath.Join(s.dir, activeSessionFile), []byte(id), 0644)
	return id, nil
}

func (s *SessionStore) GetSession(sessionID string) (*AgentSessionState, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.readSession(sessionID)
}

func (s *SessionStore) SaveSession(sessionID string, state *AgentSessionState) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	state.LastUpdated = nowMs()
	return s.writeSession(sessionID, *state)
}

func (s *SessionStore) UpdateSession(sessionID string, updates map[string]any) error {
	cur, err := s.GetSession(sessionID)
	if err != nil || cur == nil {
		return err
	}
	if title, ok := updates["title"].(string); ok {
		cur.Title = title
	}
	if h, ok := updates["geminiHistory"].([]any); ok {
		cur.GeminiHistory = h
	}
	if vfs, ok := updates["vfs"].(map[string]VfsFile); ok {
		cur.VFS = vfs
	}
	if chunks, ok := updates["knowledgeChunks"].([]KnowledgeChunk); ok {
		cur.KnowledgeChunks = chunks
	}
	if msgs, ok := updates["uiMessages"].([]any); ok {
		cur.UIMessages = msgs
	}
	return s.SaveSession(sessionID, cur)
}

func (s *SessionStore) UpdateVFS(sessionID, path, content, language string, isWriting bool) error {
	cur, err := s.GetSession(sessionID)
	if err != nil || cur == nil {
		return err
	}
	if cur.VFS == nil {
		cur.VFS = make(map[string]VfsFile)
	}
	cur.VFS[path] = VfsFile{Path: path, Content: content, Language: language, IsWriting: isWriting}
	return s.SaveSession(sessionID, cur)
}

func (s *SessionStore) ListSessions() ([]SessionMeta, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	entries, err := os.ReadDir(s.dir)
	if err != nil {
		return nil, err
	}
	var metas []SessionMeta
	for _, e := range entries {
		if e.IsDir() || filepath.Ext(e.Name()) != ".json" {
			continue
		}
		id := e.Name()[:len(e.Name())-5]
		state, err := s.readSession(id)
		if err != nil || state == nil {
			continue
		}
		title := state.Title
		if title == "" {
			title = "新会话"
		}
		metas = append(metas, SessionMeta{
			SessionID:   state.SessionID,
			Title:       title,
			LastUpdated: state.LastUpdated,
		})
	}
	sort.Slice(metas, func(i, j int) bool { return metas[i].LastUpdated > metas[j].LastUpdated })
	return metas, nil
}

func (s *SessionStore) SetActiveSession(sessionID string) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.active = sessionID
	return os.WriteFile(filepath.Join(s.dir, activeSessionFile), []byte(sessionID), 0644)
}

func (s *SessionStore) GetActiveSessionID() string {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.active
}

func (s *SessionStore) DeleteSession(sessionID string) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	p := filepath.Join(s.dir, sessionID+".json")
	if err := os.Remove(p); err != nil && !os.IsNotExist(err) {
		return err
	}
	if s.active == sessionID {
		s.active = ""
		_ = os.Remove(filepath.Join(s.dir, activeSessionFile))
	}
	return nil
}

func (s *SessionStore) ClearSessionContent(sessionID string) error {
	state := AgentSessionState{
		SessionID:      sessionID,
		Title:          "新会话",
		GeminiHistory:  []any{},
		UIMessages:     []any{},
		VFS:            DefaultVFS(),
		KnowledgeChunks: []KnowledgeChunk{},
		LastUpdated:    nowMs(),
	}
	return s.SaveSession(sessionID, &state)
}

func (s *SessionStore) GetKnowledgeChunks(sessionID string) ([]KnowledgeChunk, error) {
	cur, err := s.GetSession(sessionID)
	if err != nil || cur == nil {
		return nil, err
	}
	return cur.KnowledgeChunks, nil
}

func (s *SessionStore) AppendKnowledgeChunks(sessionID string, chunks []KnowledgeChunk) error {
	cur, err := s.GetSession(sessionID)
	if err != nil || cur == nil {
		return err
	}
	cur.KnowledgeChunks = append(cur.KnowledgeChunks, chunks...)
	return s.SaveSession(sessionID, cur)
}

func (s *SessionStore) readSession(sessionID string) (*AgentSessionState, error) {
	p := filepath.Join(s.dir, sessionID+".json")
	data, err := os.ReadFile(p)
	if err != nil {
		return nil, err
	}
	var state AgentSessionState
	if err := json.Unmarshal(data, &state); err != nil {
		return nil, err
	}
	return &state, nil
}

func (s *SessionStore) writeSession(sessionID string, state AgentSessionState) error {
	p := filepath.Join(s.dir, sessionID+".json")
	data, err := json.MarshalIndent(state, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(p, data, 0644)
}

func (s *SessionStore) readActive() (string, error) {
	data, err := os.ReadFile(filepath.Join(s.dir, activeSessionFile))
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func genSessionID() string {
	return "sess_" + randomID()
}

func randomID() string {
	return fmt.Sprintf("%x%05x", time.Now().UnixMilli(), rand.Uint32()&0xfffff)
}

func nowMs() int64 {
	return time.Now().UnixMilli()
}
